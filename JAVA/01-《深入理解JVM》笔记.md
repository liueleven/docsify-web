
# 深入理解JVM

> 写于2018-03-08

> 更新2018-07-22

### 前言
本笔记是我看深入理解JVM一书做的学习笔记，旨在了解jvm原理，反馈下自己，对于每一个知识点，我会先问自己它是什么？它有什么作用？有什么实例可以补充说明下？只有回答了这三个问句，我才能对自己说，这一点我看懂了，然后向其它人转述的过程中，可以说，然后再用实例去证明我说的，我觉得这就是我理想的看书结果。所以该笔记我会带着这三个问题去看每一个知识点。

#### 第二章：jvm自动内存管理
* 要点一：
jvm中内存是如何划分的
	Java虚拟机会在执行java程序的时候，将他所管理的内存划分为若干区域，分别是：**方法区，虚拟机栈，堆，本地方法栈，程序计数器**。
#####  1.	程序计数器
什么是程序计数器？
程序计数器在内存中只占很少的一块内存，它充当指示标记功能，例如字节码解释器就是通过它才能知道下一条要执行的字节码指令是什么，当多线程进行切换执行任务时，执行完后，又正确回到原来的位置，且各个线程之间的程序计数器是互不影响，独立存储。因此这一部分为“线程私有”。

##### 2.	虚拟机栈
什么是虚拟机栈？
虚拟机栈描述的是java方法执行的内存模型，每个方法执行时会创建一个栈帧（栈帧是方法运行期的基础数据结构），用于存储局部变量表，操作栈，动态链接，方法出口等信息，也就是说：一个方法从被调用到执行完成，也就意味着对应的一个栈帧从入栈到出栈的过程。

其中局部变量表也就是java八大基本数据类型和对象引用64位的long和double都是占用2个局部变量空间，其余都是一个，局部变量表所需的内存空间都是在编译器分配完成的。
值的一提的是虚拟机栈也是线程私有的，虚拟机栈就是为java方法服务的

 ##### 3.  本地方法栈
本地方法栈作用和虚拟机栈类似，只不过本地方法栈是为虚拟机中使用到的Native方法服务。

##### 4.	Java堆
什么是堆？
	堆的唯一目的就是用来存放对象实例。
特点：是java虚拟机中内存最大的一块区域，是所有线程共享的一块区域，在虚拟机启动时创建，几乎所有的对象实例和数组都在这里分配内存。也是垃圾收集器管理的主要区域
##### 5.	方法区
什么是方法区？
特点：方法区也是各线程共享的内存区域，它用于存放已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。在方法区，垃圾收集行为比较少，主要回收目标是针对常量池的回收和对类型的卸载
##### 6.	运行时常量池
什么是运行常量池？
是方法区的一部分。
一个class文件有类的版本，字段，方法，接口等描述信息，还有常量池。
它有什么作用？
用于存放编译期生成的各种字面量和符号引用，会在类加载后，存放到常量池中。
##### 7．直接内存
什么是直接内存？
就是本机内存，并不属于虚拟机运行时数据区中
它有什么作用？
 在java的IO中被频繁的使用到。
 


* 要点二：jvm中的内存溢出是怎样产生的

* 要点三：几款垃圾收集算法特点及原理

##### 如何判断堆中的一个对象已经死了？
1. 引用计数算法
算法思路：
    每一个堆中的对象每调用一次，都会有一个相应的引用计数器加1，当引用失效时就减1，也就是说当一个对象的引用计数器为0时，那么就可以被GC回收了。这是一个很牛的回收算法，但是java并不是通过这个算法来判断的。

2. 根搜索算法
算法思路：通过一系列名为“GC Roots”的对象最为起点，从这些节点向下搜索，搜索所走过的路称为引用链，当一个对象没有任何引用链到GC Roots，那么这个对象是不可用的，这个对象就是个可回收对象。java用的是这种算法。

##### 垃圾收集算法
1. 标记清除算法
算法思想：首先标记出所有要回收的对象，然后再清除所有被标记过的对象，这种算法有2个缺点，第一个是效率太慢，第二是被回收的地方容易产生零碎的内存，如果下次需要一个大的内存空间，又会触发一次垃圾收集动作。
2. 复制算法  这种算法将内存划分为2块大小一样的区域，每次只使用其中的一块，如果这一块用完了，就把还活着的复制到另外一块中，这样每次只要回收这一块就行了，也不用考虑到内存碎片等问题。缺点是内存缩小为原来的一半
3. 标记整理算法，它不直接清除，而是将对象先移到一端，然后再清除，避免了内存碎片化的问题
4. 分代收集算法
将对象的存活周期不同将内存分为几块，一般将java堆分为==新生代==和==老生代==，然后根据不同的年代，使用不同的回收算法进行收集
5. CMD收集器 是一种获取最短回收停顿时间为目标的收集器，时间短
 
##### 垃圾收集器
 明确一个观点：`没有最好的收集器，只有在合适的场景使用合适的收集器 `

这幅图可以看出把堆中的内存划分为2个部分，young和old，young区域有3个收集器可以使用，分别是：Serial，ParNew，Parallel Scavenge ;old有3个收集器,分别是：CMS,Serial old，Parallel Old。还有一个超级厉害的收集器G1，老少通吃！
![image](http://ww3.sinaimg.cn/large/0060lm7Tly1fpq1b0j0tvj30e20d9go2.jpg)（连线表示和可以搭配使用）

1. **Serial收集器**   这是一个新生代收集器，是个‘单线程’收集器，是许多client默认的收集器，它的特点是只用一个线程进行收集，并且它开始工作的时候，会停掉其他所有的线程（超级蛋疼！！！不过也是合情合理，比如打扫房间，边打扫，边扔垃圾，确实不行）
2. **ParNew收集器 **
这是一个新生代收集器，是Serial的多线程版，是许多server默认的收集器，它能实现所谓的边打扫边扔垃圾式收集。但是当它作为老年代收集器时，效果并不是很理想
3. **Parallel Scavenger收集器** 它也是一个新生代收集器，也是使用复制算法的收集器，又是并行的多线程收集器，它的目的是要做到可控制的==吞吐量==（吞吐量即：用户运行代码的时间/（用户运行代码的时间+垃圾收集的时间）），吞吐量越高，对CPU的利用率越高，
4. **Serial Old收集器**
是Serial的老年代版本，也是一个单线程收集器，使用标记整理算法，被Client模式下的虚拟机使用，在Server模式下2个用途：
- 和Parallel Scavenger收集器搭配使用
- 作为CMS的后备方案，发生Concurrent Mode Failure的时候使用
5. **Parallel Old**是Parallel Scavenger收集器的老年版本，使用多线程和标记整理算法，这个收集器的主要意义在于当你选择了新生代的收集器是Parallel Scavenger，那么老年代收集器就可选Parallel进行搭配工作了，因为他无法和CMS搭配使用
6. **CMS收集器** （Concurrent Mark Sweep），特点是回收目标是停顿时间最短。现在大多数B/S系统都采用的是这种回收方式。该收集器工作分为4个过程：
- 初始标记 initial mark
- 并发标记concurrent mark
- 重新标记remark
- 并发清除concurrent sweep
cms尽管很优秀，但前面已经说过没有万能的收集器，它同样也有3个缺点：
- 工作时会占用cpu资源，导致应用变慢
- 无法回收浮动的垃圾，也就是说当它在工作时用户还在工作，会产生新的垃圾，这些垃圾是没有标记过的，只能等待下一次进行回收，这就叫浮动垃圾，由于是和用户同步工作的所以要留足够的内存给用户线程使用
- 采用的标记清除算法，回收后会产生大量的碎片空间
7. **G1** 收集器（Garbage First）是基于标记整理算法的收集器，不会产生碎片空间，可以精确控制停顿

**垃圾收集器的总结：**
对于不懂年代的使用不同的收集器进行搭配使用，在Client和Server都有默认的收集器搭配组合

* **内存分配和回收策略**
自动内存管理解决了2个问题：一个是给对象分配内存，一个是回收分配给对象的内存，

要点四：常见工具故障处理
要点五：实战故障处理和调优

第三章：jvm执行子系统
要点一：class文件结构中组成部分
要点二：类的加载，类加载器工作原理
要点三：虚拟机是如何找到方法的
要点四：实战类加载器，字节码

第四章：程序的编译和代码的优化
要点一：java语法糖
要点二：编译器解析及优化

第五章：java高效并发原理
要点一：虚拟机的java内存模型的结构和操作
要点二：线程安全

### JVM参数详解
> 可以关注阿里大牛公众号：你假笨

```
JVM 常用参数详解：
-server：一定要作为第一个参数，在多个 CPU 时性能佳，还有一种叫 -client 的模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或开发调试，在 32 位环境下直接运行 Java 程序
默认启用该模式。Server 模式的特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境，在具有 64 位能力的 JDK 环境下默认启用该模式，可以不配置该参数。
-Xms：表示 Java 初始化堆的大小，-Xms 与-Xmx 设成一样的值，避免 JVM 反复重新申请内存，导致性能大起大落，默认值为物理内存的 1/64，默认（MinHeapFreeRatio参数可以调整）空余堆内存小于 40% 时，JVM 就
会增大堆直到 -Xmx 的最大限制。
-Xmx：表示最大 Java 堆大小，当应用程序需要的内存超出堆的最大值时虚拟机就会提示内存溢出，并且导致应用服务崩溃，因此一般建议堆的最大值设置为可用内存的最大值的80%。如何知道我的 JVM 能够使用最大值，
使用 java -Xmx512M -version 命令来进行测试，然后逐渐的增大 512 的值,如果执行正常就表示指定的内存大小可用，否则会打印错误信息，默认值为物理内存的 1/4，默认（MinHeapFreeRatio参数可以调整）空余堆内存大于
70% 时，JVM 会减少堆直到-Xms 的最小限制。
-Xss：表示每个 Java 线程堆栈大小，JDK 5.0 以后每个线程堆栈大小为 1M，以前每个线程堆栈大小为 256K。根据应用的线程所需内存大小进行调整，在相同物理内存下，减小这个值能生成更多的线程，但是操作系统对
一个进程内的线程数还是有限制的，不能无限生成，经验值在 3000~5000 左右。一般小的应用， 如果栈不是很深， 应该是128k 够用的，大的应用建议使用 256k 或 512K，一般不易设置超过 1M，要不然容易出现out
ofmemory。这个选项对性能影响比较大，需要严格的测试。
-XX:NewSize：设置新生代内存大小。
-XX:MaxNewSize：设置最大新生代新生代内存大小
-XX:PermSize：设置持久代内存大小
-XX:MaxPermSize：设置最大值持久代内存大小，永久代不属于堆内存，堆内存只包含新生代和老年代。
-XX:+AggressiveOpts：作用如其名（aggressive），启用这个参数，则每当 JDK 版本升级时，你的 JVM 都会使用最新加入的优化技术（如果有的话）。
-XX:+UseBiasedLocking：启用一个优化了的线程锁，我们知道在我们的appserver，每个http请求就是一个线程，有的请求短有的请求长，就会有请求排队的现象，甚至还会出现线程阻塞，这个优化了的线程锁使得你的
appserver内对线程处理自动进行最优调配。
-XX:+DisableExplicitGC：在 程序代码中不允许有显示的调用“System.gc()”。每次在到操作结束时手动调用 System.gc() 一下，付出的代价就是系统响应时间严重降低，就和关于 Xms，Xmx 里的解释的原理一样，这样去调
用 GC 导致系统的 JVM 大起大落。
-XX:+UseConcMarkSweepGC：设置年老代为并发收集，即 CMS gc，这一特性只有 jdk1.5
后续版本才具有的功能，它使用的是 gc 估算触发和 heap 占用触发。我们知道频频繁的 GC 会造面 JVM
的大起大落从而影响到系统的效率，因此使用了 CMS GC 后可以在 GC 次数增多的情况下，每次 GC 的响应时间却很短，比如说使用了 CMS
GC 后经过 jprofiler 的观察，GC 被触发次数非常多，而每次 GC 耗时仅为几毫秒。
-XX:+UseParNewGC：对新生代采用多线程并行回收，这样收得快，注意最新的 JVM 版本，当使用 -XX:+UseConcMarkSweepGC 时，-XX:UseParNewGC 会自动开启。因此，如果年轻代的并行 GC 不想开启，可以通过
设置 -XX：-UseParNewGC 来关掉。
-XX:MaxTenuringThreshold：设置垃圾最大年龄。如果设置为0的话，则新生代对象不经过 Survivor 区，直接进入老年代。对于老年代比较多的应用（需要大量常驻内存的应用），可以提高效率。如果将此值设置为一 个较
大值，则新生代对象会在 Survivor 区进行多次复制，这样可以增加对象在新生代的存活时间，增加在新生代即被回收的概率，减少Full GC的频率，这样做可以在某种程度上提高服务稳定性。该参数只有在串行 GC 时才有效，这
个值的设置是根据本地的 jprofiler 监控后得到的一个理想的值，不能一概而论原搬照抄。
-XX:+CMSParallelRemarkEnabled：在使用 UseParNewGC 的情况下，尽量减少 mark 的时间。
-XX:+UseCMSCompactAtFullCollection：在使用 concurrent gc 的情况下，防止 memoryfragmention，对 live object 进行整理，使 memory 碎片减少。
-XX:LargePageSizeInBytes：指定 Java heap 的分页页面大小，内存页的大小不可设置过大， 会影响 Perm 的大小。
-XX:+UseFastAccessorMethods：使用 get，set 方法转成本地代码，原始类型的快速优化。
-XX:+UseCMSInitiatingOccupancyOnly：只有在 oldgeneration 在使用了初始化的比例后 concurrent collector 启动收集。
-Duser.timezone=Asia/Shanghai：设置用户所在时区。
-Djava.awt.headless=true：这个参数一般我们都是放在最后使用的，这全参数的作用是这样的，有时我们会在我们的 J2EE 工程中使用一些图表工具如：jfreechart，用于在 web 网页输出 GIF/JPG 等流，在 winodws 环境
下，一般我们的 app server 在输出图形时不会碰到什么问题，但是在linux/unix 环境下经常会碰到一个 exception 导致你在 winodws 开发环境下图片显示的好好可是在 linux/unix 下却显示不出来，因此加上这个参数以免避这样的
情况出现。
-Xmn：新生代的内存空间大小，注意：此处的大小是（eden+ 2 survivor space)。与 jmap -heap 中显示的 New gen 是不同的。整个堆大小 = 新生代大小 + 老生代大小 + 永久代大小。在保证堆大小不变的情况下，增大新生
代后，将会减小老生代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的 3/8。
-XX:CMSInitiatingOccupancyFraction：当堆满之后，并行收集器便开始进行垃圾收集，例如，当没有足够的空间来容纳新分配或提升的对象。对于 CMS 收集器，长时间等待是不可取的，因为在并发垃圾收集期间应用持续
在运行（并且分配对象）。因此，为了在应用程序使用完内存之前完成垃圾收集周期，CMS 收集器要比并行收集器更先启动。因为不同的应用会有不同对象分配模式，JVM 会收集实际的对象分配（和释放）的运行时数据，并
且分析这些数据，来决定什么时候启动一次 CMS 垃圾收集周期。这个参数设置有很大技巧，基本上满足(Xmx-Xmn)*(100-CMSInitiatingOccupancyFraction)/100 >= Xmn 就不会出现 promotion failed。例如在应用中 Xmx 是
6000，Xmn 是 512，那么 Xmx-Xmn 是 5488M，也就是老年代有 5488M，CMSInitiatingOccupancyFraction=90 说明老年代到 90% 满的时候开始执行对老年代的并发垃圾回收（CMS），这时还 剩 10% 的空间是 5488*10% =
548M，所以即使 Xmn（也就是新生代共512M）里所有对象都搬到老年代里，548M 的空间也足够了，所以只要满足上面的公式，就不会出现垃圾回收时的 promotion failed，因此这个参数的设置必须与 Xmn 关联在一起。
-XX:+CMSIncrementalMode：该标志将开启 CMS 收集器的增量模式。增量模式经常暂停 CMS 过程，以便对应用程序线程作出完全的让步。因此，收集器将花更长的时间完成整个收集周期。因此，只有通过测试后发现正
常 CMS 周期对应用程序线程干扰太大时，才应该使用增量模式。由于现代服务器有足够的处理器来适应并发的垃圾收集，所以这种情况发生得很少，用于但 CPU情况。
-XX:NewRatio：年轻代（包括 Eden 和两个 Survivor 区）与年老代的比值（除去持久代），-XX:NewRatio=4 表示年轻代与年老代所占比值为 1:4，年轻代占整个堆栈的 1/5，Xms=Xmx 并且设置了 Xmn 的情况下，该参数
不需要进行设置。
-XX:SurvivorRatio：Eden 区与 Survivor 区的大小比值，设置为 8，表示 2 个 Survivor 区（JVM 堆内存年轻代中默认有 2 个大小相等的 Survivor 区）与 1 个 Eden 区的比值为 2:8，即 1 个 Survivor 区占整个年轻代大小的
1/10。
-XX:+UseSerialGC：设置串行收集器。
-XX:+UseParallelGC：设置为并行收集器。此配置仅对年轻代有效。即年轻代使用并行收集，而年老代仍使用串行收集。
-XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集，JDK6.0 开始支持对年老代并行收集。
-XX:ConcGCThreads：早期 JVM 版本也叫-XX:ParallelCMSThreads，定义并发 CMS 过程运行时的线程数。比如 value=4 意味着 CMS 周期的所有阶段都以 4 个线程来执行。尽管更多的线程会加快并发 CMS 过程，但其也
会带来额外的同步开销。因此，对于特定的应用程序，应该通过测试来判断增加 CMS 线程数是否真的能够带来性能的提升。如果还标志未设置，JVM 会根据并行收集器中的 -XX:ParallelGCThreads 参数的值来计算出默认的并
行 CMS 线程数。
-XX:ParallelGCThreads：配置并行收集器的线程数，即：同时有多少个线程一起进行垃圾回收，此值建议配置与 CPU 数目相等。
-XX:OldSize：设置 JVM 启动分配的老年代内存大小，类似于新生代内存的初始大小 -XX:NewSize。
以上就是一些常用的配置参数，有些参数是可以被替代的，配置思路需要考虑的是 Java 提供的垃圾回收机制。虚拟机的堆大小决定了虚拟机花费在收集垃圾上的时间和频度。收集垃圾能够接受的速度和应用有关，应该通过
分析实际的垃圾收集的时间和频率来调整。假如堆的大小很大，那么完全垃圾收集就会很慢，但是频度会降低。假如您把堆的大小和内存的需要一致，完全收集就很快，但是会更加频繁。调整堆大小的的目的是最小化垃圾收集
的时间，以在特定的时间内最大化处理客户的请求。在基准测试的时候，为确保最好的性能，要把堆的大小设大，确保垃圾收集不在整个基准测试的过程中出现。

```

