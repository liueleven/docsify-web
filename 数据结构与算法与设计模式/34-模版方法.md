# 模版方法
> 写于：2018-11-11

> 定义类一个算法骨架，并允许子类为一个或多个步骤提供实现

### 类型
属于行为型

### 适用场景
一次行完成算法不变的部分，让可变的部分留给子类去实现

### 优点
复用、可扩展，符合开闭原则

### 缺点
因为父类定义类模板骨架，如果修改类父类子类也要改变；子类要去继承父类，类的数量增多，增加系统的复杂度

### 代码
先创建一个Vidio
```
public abstract class Video {

    public abstract void produce();

}
```

2个子类继承
```
public class JavaVideo extends Video{

    @Override
    public void produce() {
        System.out.println("java 视频");
    }
}

public class PythonVideo extends Video{

    @Override
    public void produce() {
        System.out.println("python 视频");
    }
}
```
简单工厂，生成具体产品
```
public class VideoFactory {

 
    /**
     * 方式1
     */
    public Video produce(String type) {

        if("java".equalsIgnoreCase(type)) {
            return new JavaVideo();
        } else if("python".equalsIgnoreCase(type)) {
            return new PythonVideo();
        }
        return null;
    }
    
    /**
     * 方式2 利用反射弥补简单工厂的不足
     * @param clazz
     * @return
     */
    public Video produce(Class clazz) {
        Video video = null;
        try {
            video = (Video) Class.forName(clazz.getName()).newInstance();
        } catch (InstantiationException e) {
            e.printStackTrace();
        } catch (IllegalAccessException e) {
            e.printStackTrace();
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
        return video;
    }
}
```
### 扩展
- JDK源码中`java.util.Calendar.java`类
- `org.slf4j.LoggerFactory.java`类





