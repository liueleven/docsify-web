# 初识JVM(一)——运行时数据区

更新于2018-07-22

> 不容易，第一次看这本书是因为看了一句话，“jvm是任何一个java程序员都要了解的知识”，然后国内比较出名的就是《深入理解jvm虚拟机》，怀着好奇的心态，看看到底是什么鬼，翻开了这本书，看了半天，看吐了，放！弃！第二次真心决定要看这本书，是因为有一次系统莫名其妙就停了，那时感叹jvm这方面知识太重要了，很认真的再次打开了（认真的脸.jpg），边看边做笔记，不懂的名词百度查，半天后还是吐了，放！弃！今天再次打开它，还是有想吐的感觉，但被我咽回去了，慢慢的看的越来越有感觉，“哦，原来是这样啊！”这句话不断从脑海冒出来，有些东西没到火候看，真是送命题，不容易！


#### 读完本篇，你能获得啥？
- JVM运行时数据区
- 数据区中的职责


### 什么是JVM?
> java virtual machine java虚拟机

### JVM能干什么？
> 最著名的那句话“一次编译到处运行”，也就是将java翻译成机器码；第二个就是内存管理了


### 常见名词
- 运行时数据区
    > jvm在执行java程序的过程中，会把它所管理的内存划分为若干个不同的数据区域
    
    - 方法区
         > 是用来存放被虚拟机加载的类信息、常量、静态变量等数据，也是线程共享的。在这个区域的变量很少出现垃圾回收器，主要是对常量池的回收和对类的卸载。如果方法区的内存不足，就会抛出OutOfMemoryError

    - 运行时常量池
        > 它是方法区的一部分，存放编译期生成的各种字面量和符号引用，在类加载后，这部分内容会存放到方法区的常量池中。当内存不足时，也会抛出OutOfMemoryError

    - 堆
         > 这块内存是jvm中占内存最大的一块区域，用来存放对象实例，所以是线程共享的。堆中的内存很大，又可以分为新生代和老生代。堆中的内存空间在物理上可以是不连续的，逻辑上要保证连续即可。可以通过-Xmx和Xms来控制大小。如果堆种没有内存完成实例的分配就会抛出OutOfMemoryError异常

    - 程序计数器
         > 当前线程所执行的行号指示器，指示当前要去执行哪一步，每个线程都有一个私有的程序计数器，必须互不影响，才能保证线程的正常切换，该内存属于线程私有的
         
    - 虚拟机栈
         > 每一个方法被调用都会创建一个**栈帧**，用来保存局部变量表，方法出口等方法信息，当所有的信息都出栈了，该方法也就执行完了。如果一个方法中变量很多，栈的深度大于虚拟机所允许的栈深度就会抛出StackOverflowError，当然虚拟机栈也可以动态拓展的，但是如果动态拓展也无法申请到足够的内存就会抛出OutMemoryError
         
    - 本地方法栈
         > 和虚拟机栈非常相似，不同的是本地方法栈是调用Native方法时才使用的
         
    
        
    - JMM
        > JAVA内存模型
        
        
### 垃圾收集器
#### 三个非常重要的问题：
* 哪些内存需要回收呢？
* 什么时候回收呢？
* 如何回收呢？
#### 对象回收算法

- 引用计数算法
> 核心思想是：如果一个对象被引用那么该对象的计数器就加1，没有引用计数器就减1，如果该对象的计数器等于0，那么这个对象就认为是没有被引用。**这是个效率很高很出名的算法，但是java并没有采用这种算法，因为它无法解决对象相互循环引用的问题**

- 根搜索算法
> 核心思想是：以**当前存活的对象为root**，遍历出所有和他们相关联的对象，如果没有遍历到，那么这个对象不可用，可以被回收。以下几种均属于**当前存活对象：**
        
    
    - 虚拟机栈帧中的引用对象
    - 方法区中的类静态属性引用的对象
    - 方法区中的常量引用对象
    - 本地方法中JNI的引用对象
    - 
#### 垃圾收集算法
> 先记住这一句话：现在的收集器大多采用**分代回收算法**
- 标记清除算法
> 核心思想是：该算法分为标记和清除两个阶段，先标记需要回收的对象，然后再统一回收。**缺点：**一个是效率不高；另外一个重要原因是空间问题，会产生大量的内存碎片，导致在后面如果有大的对象无法找到足够的内存存放，不得不提前触发另一次垃圾收集动作![image](https://img-blog.csdn.net/20180503093912473?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXppcWluZzIwMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/7)

- 复制算法
> 为了解决效率问题，就有了复制算法。
> 核心思想是：将可用内存分为大小相等的2块，一次只使用其中的一块内存，当这个一块内存用完了，就把活着的对象复制到另外一块上面，然后把原来的那块清理掉，就不用考虑内存碎片的问题。**缺点：**内存空间会缩短为原来的一半（空间换时间的感觉）。
现在的大多数虚拟机都是用这种算法来回收**新生代**，因为新生代中的对象98%都是朝生夕死的，所以不需要按1：1分配空间，而是分为一块80%的Eden空间，2块10%的survivor空间，使用时将对象先放到Eden和一块survivor空间中，然后被标记清除算法处理后，再复制到另外一块崭新的survivor空间中，这样空间就不会被浪费了**但是**有时候一旦活着的新生代超过了10%怎么办呢？我们需要向其它内存（比如老年代）借一点先用用，用完后再还给他![image](https://img-blog.csdn.net/20180503095221999?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXppcWluZzIwMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 标记整理算法
> 上面的算法完美的解决了新生代的问题，但是老年代怎么办？根据老年代的特点，提出了**标记整理算法**，核心思想是：先标记出可以回收的对象，然后再把它们统一向一端移动，然后再清除![image](https://img-blog.csdn.net/20180503102624992?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXppcWluZzIwMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

- 分代回收算法
> 核心思想是：这是大多数都采用的算法，它提出将对象按存活周期划分，一般把堆分为新生代和老年代，然后根据各自的特点，使用不同的回收算法，也就是上面提到的那几种。

#### 垃圾收集器
> 有了前面对象回收算法和垃圾算法的理论上铺垫，现在就差一步就可以收了这群“垃圾”了，垃圾收集器![image](https://img-blog.csdn.net/2018050310382690?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXppcWluZzIwMTM=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

这7种收集器，上面是新生代，下面是老年代，连线的表示可以搭配使用，都有各自的优缺点和使用场景。下面一一介绍下：


- Serial收集器
> **个人简历**：最基本、最古老的收集器，在jdk1.3.1之前是新生代的唯一选择（没得选，就这么一个傻儿子）


> **特长**：几乎没有特长（捂脸），说他简单高效，是因为他是单线程的，没有线程之间的交互开销；但是在单CPU下，几乎无敌


> **缺点**：1.他很慢，是单线程的，所以效率不是很高；2.他很霸道，他进行垃圾收集时，要暂停其他所有工作线程；

> **应用**：在client端（桌面应用中）新生代不会很大，所以他是一个比较好的选择

- ParNew收集器
> **个人简历**：升级版的Serial，从单线程升级到了多线程；Server端首选主角


> **特长**：都多线程了，你懂的；除了Serial（Server端基本不用他了），他是唯一可以和CMS搭配使用的新生代收集器


> **缺点**：如果是在单CPU下，由于线程之间的切换开销，还不如Serial

> **应用**：Server端中和CMS搭配首选新生代收集器

- Parallel Scavenge收集器
> **个人简历**：收集器中的一股泥石流，当其他收集器还在考虑如何更快时，Parallel的目的则是**可控制的吞吐量**（吞吐量=运行代码时间/(运行代码时间+垃圾收集时间)，假设虚拟机总共运行了100分钟=垃圾收集器时间1分钟+运行代码时间99分钟，那么吞吐量就是99%）


> **特长**：ParNew有的我都有，并且还能控制吞吐量，就问你们可怕不可怕！！！

> **缺点**：同ParNew

---

- Serial Old 
> **个人简历**：Serial的老年版，主要还是在Client模式使用，还可以作为CMS收集器的预备方案


> **特长**：老年版的Serial

> **缺点**：同Serial

> **应用**：Client模式下，还可以作为CMS收集器的预备方案


- Parallel Old 
> **个人简历**：是Parallel Scavenge的老年版本，使用多线程标记整理算法

> **应用**： 是Parallel Scavenge的收集器的最佳组合

- CMS（Concurrent Mark Sweep）
> **个人简历**：听名字就很厉害，立志要做到最短回收停顿时间，目前B/S系统上非常适合这个收集器

> **工作原理**：CMS是基于标记清除算法的，为了追求时间，运行过程也更加的复杂，分为4个过程：

    - 初始标记
    - 并发标记
    - 重新标记
    - 并发清除
    
> **特点**：并发收集，低停顿   

> **缺点**：由于是并发设计，会占用CPU资源，导致应用程序变慢；无法处理浮动垃圾；标记清除算法是会产生碎片空间的（虽然缺点很多，但是只要cpu资源满足，其他问题都是可以通过-XX：进行调优的，所以还是优秀的收集器）


> **应用**： 在B/S系统中比较受欢迎

- G1(Garbage First)

G1收集器本书中描述的比较模糊，可以参考这个[链接](http://www.oracle.com/technetwork/cn/articles/java/g1gc-1984535-zhs.html)

### 虚拟机执行子系统
> java程序(xxx.java) -> javac编译器 -> 字节码(xxx.class) -> java虚拟机 

### java内存模型与内存

- TPS(Transactions Per Second)：每秒事物处理数，是衡量一个服务性能的高低好坏的重要指标
- JMM(Java Memory Model)：java内存模型，用来解决访问内存一致性
# 还有最后一章没有看完，是关于并发的